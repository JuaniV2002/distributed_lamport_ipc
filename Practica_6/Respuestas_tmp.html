<!DOCTYPE html>
<html>
<head>
<title>Respuestas.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="practica-6-sistemas-distribuidos">Practica 6: Sistemas Distribuidos</h2>
<p><strong>1)</strong> Una vez llegados los dos comandos con el mismo timestamp, lo que se suguiere es que la prioridad esté puesta en el que tenga el menor tiempo, en caso de que los mensajes ingresantes tengan el mismo tiempo se ordenan los mensajes por identificador de proceso.</p>
<pre class="hljs"><code><div>// works es una cola de mensajes que seran ejecutados por los nodos
// m1 : mensaje de nodo1
// m2 : mensaje de nodo2
// ID1 : identificador del nodo1
// ID2 : identificador del nodo2
// t1 : timestamp del mensaje del nodo1
// t2 : timestamp del mensaje del nodo2


if t1 &lt; t2 then
    works.enqueue(m1)
    works.enqueue(m2)
else if t1 &gt; t2 then
    works.enqueue(m2)
    works.enqueue(m1)
else 
    if ID1.ip &lt; ID2.ip then
        works.enqueue(m1)
        works.enqueue(m2)
    else if ID1.ip &gt; ID2.ip then
        works.enqueue(m2)
        works.enqueue(m1)
    else if ID1.port &lt; ID2.port then
        works.enqueue(m1)
        works.enqueue(m2)
    else
        works.enqueue(m2)
        works.enqueue(m1)
</div></code></pre>
<p><strong>2)</strong> El algoritmo trabajaría de la siguiente manera:</p>
<p>Cada nodo cuenta con un id unico que lo diferencia del resto.</p>
<p>Cada mensaje enviado debe tener un identificador único, un número de identificación del nodo que lo envió y un número de secuencia que será inicalmente 0. Esto permite a los nodos identificar el orden de los mensajes.</p>
<blockquote>
<p>Partes:</p>
</blockquote>
<p><strong>Broker Central</strong>: actúa como intermediario para recibir y redistribuir los mensajes. Será responsable de mantener el orden de los mensajes. Este cuenta con una cola de distribución.</p>
<p><strong>Nodos</strong>: participantes del sistema.</p>
<blockquote>
<p>Proceso:</p>
</blockquote>
<p>Cuando un nodo envía un mensaje, el broker lo recibe, le asigna un valor de secuencia (sustituyendo el 0) y lo almacena en una cola de mensajes.</p>
<p>Para la asignación de un número de secuencia, el broker emplea el algoritmo del inciso anterior con el cuál define que mensaje tiene mas precedencia.</p>
<p><strong>Confirmación de Recepción</strong>: cada nodo que recibe un mensaje debe enviar una confirmación de recepción al broker. Sólo cuando el broker recibe confirmación de cada nodo para un mensaje específico, puede proceder a enviar el siguiente mensaje en la cola y sacar esa instrucción de su subcola.</p>
<p><strong>Reintentos</strong>: en caso de que un mensaje no sea confirmado por un nodo dentro de un tiempo determinado, el broker puede reintentar enviar el mensaje dos veces más.</p>
<p><strong>Finalización</strong>: Una vez que todos los mensajes han sido entregados y confirmados, el broker puede cerrar la sesión o continuar con el siguiente ciclo de mensajes.</p>
<p><strong>3)</strong> <img src="file:///Users/juani/programs/redes/project/Practica_6/corte.png" alt="corte.png"></p>
<p>⇒ El corte (c2) es inconsistente por la razón de que abarca el recibir del mensaje m2 y el recibir de m3, pero no cubre el enviar de ninguno de los dos, lo cual no corresponde con la idea.</p>
<p><strong>4)</strong> Desde el punto de vista de réplicas, los algoritmos de consenso mantienen que todos los nodos involucrados en el sistema distribuído deben llegar a un acuerdo común sobre el estado de los elementos replicados. Y ayudan a solucionar el problema de la siguiente manera:</p>
<ul>
<li>
<p><strong>Mantenimiento de la coherencia</strong>: todos los nodos tienen una visión consistente del estado de los elementos replicados.</p>
</li>
<li>
<p><strong>Resolución de conflictos</strong>: en caso de que surjan conflictos entre los nodos debido a actualizaciones concurrentes o fallos en la comunicación, proporcionan un mecanismo para resolver estos conflictos y llegar a un acuerdo común.</p>
</li>
<li>
<p><strong>Garantía de la integridad</strong>: aseguran que los datos replicados sean consistentes y no se pierdan o corrompan durante la replicación.</p>
</li>
</ul>
<p><strong>6)</strong>  Asumimos una topología de árbol la cual produce una secuencia de bloqueos desde la raíz hasta las hojas, además, asumimos que no hay errores y que los mensajes que se envían son los de <code>barrier</code> y <code>barrier ack</code>.</p>
<p><strong>Inicialización</strong>: cada proceso tiene un identificador único y conoce el número de procesos hijos.</p>
<p><strong>Fase de Entrada</strong>: cada proceso llama a la función <code>barrier()</code>. Se obtinen el rank del proceso y el conjunto de sus procesos hijos.</p>
<p><strong>Fase de comunicación</strong>: cada proceso que no tenga hijos (nodos hojas) envia a su padre un mensaje &quot;barrier&quot; indicando que se bloqueo, luego se queda esperando un mensaje &quot;barrier ack&quot; el cual le permite seguir con su ejecución.</p>
<p>Cada proceso con hijos comienza a recibir los mensajes &quot;barrier&quot; de sus procesos hijos, luego de recibirlos todos, envia un mensaje &quot;barrier&quot; a su padre y se queda esperando una confirmación, y por último envía un mensaje &quot;barrier ack&quot; a sus hijos.</p>
<p><strong>Fase de salida</strong>: todos los procesos continúan con su ejecución después de recibir el barrier ack.</p>
<pre class="hljs"><code><div>function barrier() {
    // Obtener el idetificador del proceso
    rank = get_rank()  
    // Obtener la cantidad de nodos hijos
    children = get_children()  

    // nodo raiz es quien lleva el registro

    if len(children) &gt; 0 {
        for i on children do
            // Recibir mensaje de otro nodo (bloquea nodo)
            receive_from(children)  
        end for

        parent = get_parent()
        if parent {
            send_to(parent, &quot;barrier&quot;)
            // Recibimos el ack del padre
            receive_from(parent)
        }

        for i on children do
            // Responde a los nodos
            send_to(i, &quot;barrier ack&quot;)
        end for
    } else {

        parent = get_parent(rank)
        // Enviar conteo local al padre
        send_to(parent, &quot;barrier&quot;)

        // Esperar la respuesta del nodo raiz (ack)
        receive_from(parent)  
    }
}
</div></code></pre>

</body>
</html>
